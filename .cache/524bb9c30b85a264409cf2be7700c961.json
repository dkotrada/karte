{"dependencies":[{"name":"util","loc":{"line":3,"column":16}},{"name":"require_optional","loc":{"line":4,"column":31}},{"name":"../connection/commands","loc":{"line":5,"column":20}},{"name":"../error","loc":{"line":6,"column":25}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n\"use strict\";\n\nvar f = require('util').format\n  , require_optional = require('require_optional')\n  , Query = require('../connection/commands').Query\n  , MongoError = require('../error');\n\nvar AuthSession = function(db, username, password, options) {\n  this.db = db;\n  this.username = username;\n  this.password = password;\n  this.options = options;\n}\n\nAuthSession.prototype.equal = function(session) {\n  return session.db == this.db\n    && session.username == this.username\n    && session.password == this.password;\n}\n\n// Kerberos class\nvar Kerberos = null;\nvar MongoAuthProcess = null;\n\n// Try to grab the Kerberos class\ntry {\n  Kerberos = require_optional('kerberos').Kerberos\n  // Authentication process for Mongo\n  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess\n} catch(err) {}\n\n/**\n * Creates a new SSPI authentication mechanism\n * @class\n * @return {SSPI} A cursor instance\n */\nvar SSPI = function(bson) {\n  this.bson = bson;\n  this.authStore = [];\n}\n\n/**\n * Authenticate\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {string} db Name of the database\n * @param {string} username Username\n * @param {string} password Password\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\nSSPI.prototype.auth = function(server, connections, db, username, password, options, callback) {\n  var self = this;\n  // We don't have the Kerberos library\n  if(Kerberos == null) return callback(new Error(\"Kerberos library is not installed\"));\n  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';\n  // Total connections\n  var count = connections.length;\n  if(count == 0) return callback(null, null);\n\n  // Valid connections\n  var numberOfValidConnections = 0;\n  var errorObject = null;\n\n  // For each connection we need to authenticate\n  while(connections.length > 0) {\n    // Execute MongoCR\n    var execute = function(connection) {\n      // Start Auth process for a connection\n      SSIPAuthenticate(self, username, password, gssapiServiceName, server, connection, options, function(err, r) {\n        // Adjust count\n        count = count - 1;\n\n        // If we have an error\n        if(err) {\n          errorObject = err;\n        } else if(r && typeof r == 'object' && r.result['$err']) {\n          errorObject = r.result;\n        } else if(r && typeof r == 'object' && r.result['errmsg']) {\n          errorObject = r.result;\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        }\n\n        // We have authenticated all connections\n        if(count == 0 && numberOfValidConnections > 0) {\n          // Store the auth details\n          addAuthSession(self.authStore, new AuthSession(db, username, password, options));\n          // Return correct authentication\n          callback(null, true);\n        } else if(count == 0) {\n          if(errorObject == null) errorObject = new MongoError(f(\"failed to authenticate using mongocr\"));\n          callback(errorObject, false);\n        }\n      });\n    }\n\n    var _execute = function(_connection) {\n      process.nextTick(function() {\n        execute(_connection);\n      });\n    }\n\n    _execute(connections.shift());\n  }\n}\n\nvar SSIPAuthenticate = function(self, username, password, gssapiServiceName, server, connection, options, callback) {\n  // Build Authentication command to send to MongoDB\n  var command = {\n      saslStart: 1\n    , mechanism: 'GSSAPI'\n    , payload: ''\n    , autoAuthorize: 1\n  };\n\n  // Create authenticator\n  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);\n\n  // Execute first sasl step\n  server(connection, new Query(self.bson, \"$external.$cmd\", command, {\n    numberToSkip: 0, numberToReturn: 1\n  }), function(err, r) {\n    if(err) return callback(err, false);\n    var doc = r.result;\n\n    mongo_auth_process.init(username, password, function(err) {\n      if(err) return callback(err);\n\n      mongo_auth_process.transition(doc.payload, function(err, payload) {\n        if(err) return callback(err);\n\n        // Perform the next step against mongod\n        var command = {\n            saslContinue: 1\n          , conversationId: doc.conversationId\n          , payload: payload\n        };\n\n        // Execute the command\n        server(connection, new Query(self.bson, \"$external.$cmd\", command, {\n          numberToSkip: 0, numberToReturn: 1\n        }), function(err, r) {\n          if(err) return callback(err, false);\n          var doc = r.result;\n\n          mongo_auth_process.transition(doc.payload, function(err, payload) {\n            if(err) return callback(err);\n\n            // Perform the next step against mongod\n            var command = {\n                saslContinue: 1\n              , conversationId: doc.conversationId\n              , payload: payload\n            };\n\n            // Execute the command\n            server(connection, new Query(self.bson, \"$external.$cmd\", command, {\n              numberToSkip: 0, numberToReturn: 1\n            }), function(err, r) {\n              if(err) return callback(err, false);\n              var doc = r.result;\n\n              mongo_auth_process.transition(doc.payload, function(err, payload) {\n                // Perform the next step against mongod\n                var command = {\n                    saslContinue: 1\n                  , conversationId: doc.conversationId\n                  , payload: payload\n                };\n\n                // Execute the command\n                server(connection, new Query(self.bson, \"$external.$cmd\", command, {\n                  numberToSkip: 0, numberToReturn: 1\n                }), function(err, r) {\n                  if(err) return callback(err, false);\n                  var doc = r.result;\n\n                  if(doc.done) return callback(null, true);\n                  callback(new Error(\"Authentication failed\"), false);\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\n// Add to store only if it does not exist\nvar addAuthSession = function(authStore, session) {\n  var found = false;\n\n  for(var i = 0; i < authStore.length; i++) {\n    if(authStore[i].equal(session)) {\n      found = true;\n      break;\n    }\n  }\n\n  if(!found) authStore.push(session);\n}\n\n/**\n * Remove authStore credentials\n * @method\n * @param {string} db Name of database we are removing authStore details about\n * @return {object}\n */\nSSPI.prototype.logout = function(dbName) {\n  this.authStore = this.authStore.filter(function(x) {\n    return x.db != dbName;\n  });\n}\n\n/**\n * Re authenticate pool\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\nSSPI.prototype.reauthenticate = function(server, connections, callback) {\n  var authStore = this.authStore.slice(0);\n  var count = authStore.length;\n  if(count == 0) return callback(null, null);\n  // Iterate over all the auth details stored\n  for(var i = 0; i < authStore.length; i++) {\n    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function(err) {\n      count = count - 1;\n      // Done re-authenticating\n      if(count == 0) {\n        callback(err, null);\n      }\n    });\n  }\n}\n\n/**\n * This is a result from a authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\nmodule.exports = SSPI;\n"},"hash":"e81fdbb413b5266a45570d0f3d184f51"}