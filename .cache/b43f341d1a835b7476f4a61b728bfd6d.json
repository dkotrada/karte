{"dependencies":[{"name":"os","loc":{"line":3,"column":17}},{"name":"util","loc":{"line":4,"column":14}},{"name":"../../package.json","loc":{"line":17,"column":28}},{"name":"process"},{"name":"buffer"}],"generated":{"js":"var process = require(\"process\");\nvar Buffer = require(\"buffer\").Buffer;\n\"use strict\"\n\nvar os = require('os'),\n  f = require('util').format;\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if(self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\n// Get package.json variable\nvar driverVersion = require('../../package.json').version;\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\nvar type = os.type();\nvar name = process.platform;\nvar architecture = process.arch;\nvar release = os.release();\n\nfunction createClientInfo(options) {\n  // Build default client information\n  var clientInfo = options.clientInfo ? clone(options.clientInfo) : {\n    driver: {\n      name: \"nodejs-core\",\n      version: driverVersion\n    },\n    os: {\n      type: type,\n      name: name,\n      architecture: architecture,\n      version: release\n    }\n  }\n\n  // Is platform specified\n  if(clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') == -1) {\n    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);\n  } else if(!clientInfo.platform){\n    clientInfo.platform = nodejsversion;\n  }\n\n  // Do we have an application specific string\n  if(options.appname) {\n    // Cut at 128 bytes\n    var buffer = new Buffer(options.appname);\n    // Return the truncated appname\n    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname;\n    // Add to the clientInfo\n    clientInfo.application = { name: appname };\n  }\n\n  return clientInfo;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function(self) {\n  if(!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [], hosts: [], passives: [], type: 'Unknown'\n    }\n  }\n\n  return self.s.serverDescription;\n}\n\nvar emitServerDescriptionChanged = function(self, description) {\n  if(self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n}\n\nvar getPreviousTopologyDescription = function(self) {\n  if(!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name, arbiters: [], hosts: [], passives: [], type: 'Unknown'\n      }]\n    }\n  }\n\n  return self.s.topologyDescription;\n}\n\nvar emitTopologyDescriptionChanged = function(self, description) {\n  if(self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n}\n\nvar changedIsMaster = function(self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if(newType != currentType) return true;\n  return false;\n}\n\nvar getTopologyType = function(self, ismaster) {\n  if(!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if(!ismaster) return 'Unknown';\n  if(ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';\n  if(ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if(ismaster.ismaster) return 'RSPrimary';\n  if(ismaster.secondary) return 'RSSecondary';\n  if(ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n}\n\nvar inquireServerState = function(self) {\n  return function(callback) {\n    if(self.s.state == 'destroyed') return;\n    // Record response time\n    var start = new Date().getTime();\n\n    // emitSDAMEvent\n    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });\n\n    // Attempt to execute ismaster command\n    self.command('admin.$cmd', { ismaster:true },  { monitoring:true }, function(err, r) {\n      if(!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self);\n\n        // Calculate latencyMS\n        var latencyMS = new Date().getTime() - start;\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', { durationMS: latencyMS, reply: r.result, connectionId: self.name });\n\n        // Did the server change\n        if(changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        }\n\n        // Updat ismaster view\n        self.s.ismaster = r.result;\n\n        // Set server response time\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', { durationMS: latencyMS, failure: err, connectionId: self.name });\n      }\n\n      // Peforming an ismaster monitoring callback operation\n      if(typeof callback == 'function') {\n        return callback(err, r);\n      }\n\n      // Perform another sweep\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}\n\n//\n// Clone the options\nvar cloneOptions = function(options) {\n  var opts = {};\n  for(var name in options) {\n    opts[name] = options[name];\n  }\n  return opts;\n}\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(function() {\n        fn();\n        if (timer && timer._called === undefined) {\n          // The artificial _called is set here for compatibility with node.js 0.10.x/0.12.x versions\n          timer._called = true;\n        }\n      }, time);\n    }\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    if(timer && timer._called) return false;\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }\n\n  // Previous entry\n  if(!previous) {\n    previous = { servers: [] };\n  }\n\n  // Check if we have any previous servers missing in the current ones\n  for(var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for(var j = 0; j < current.servers.length; j++) {\n      if(current.servers[j].address.toLowerCase()\n        === previous.servers[i].address.toLowerCase()) {\n          found = true;\n          break;\n        }\n    }\n\n    if(!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown',\n      });\n    }\n  }\n\n  // Check if there are any severs that don't exist\n  for(var j = 0; j < current.servers.length; j++) {\n    var found = false;\n\n    // Go over all the previous servers\n    for(var i = 0; i < previous.servers.length; i++) {\n      if(previous.servers[i].address.toLowerCase()\n        === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    // Add the server to the diff\n    if(!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type,\n      });\n    }\n  }\n\n  // Got through all the servers\n  for(var i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i];\n\n    // Go through all current servers\n    for(var j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j];\n\n      // Matching server\n      if(prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if(prevServer.type != currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  }\n\n  // Return difference\n  return diff;\n}\n\nmodule.exports.inquireServerState = inquireServerState\nmodule.exports.getTopologyType = getTopologyType;\nmodule.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;\nmodule.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;\nmodule.exports.cloneOptions = cloneOptions;\nmodule.exports.createClientInfo = createClientInfo;\nmodule.exports.clone = clone;\nmodule.exports.diff = diff;\nmodule.exports.Interval = Interval;\nmodule.exports.Timeout = Timeout;\n"},"hash":"cf7a193f32ac58a165086d38e5c0eadc"}