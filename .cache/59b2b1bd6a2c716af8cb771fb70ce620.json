{"dependencies":[],"generated":{"js":"// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  $hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if ('function' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              try {\n                return currPre.apply(self, preArgs);\n              } catch (error) {\n                _next(error);\n              }\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  removePost: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  \n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    fn.apply(scope, arguments);\n  };\n}\n"},"hash":"921f3cdffc2d76e97570b6ae3855a2aa"}