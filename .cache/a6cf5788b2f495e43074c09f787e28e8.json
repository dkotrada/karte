{"dependencies":[{"name":"./document","loc":{"line":5,"column":29}},{"name":"events","loc":{"line":6,"column":27}},{"name":"./error","loc":{"line":14,"column":27}},{"name":"./schema","loc":{"line":8,"column":21}},{"name":"./types/objectid","loc":{"line":9,"column":23}},{"name":"./utils","loc":{"line":10,"column":20}},{"name":"./internal","loc":{"line":12,"column":28}},{"name":"./promise_provider","loc":{"line":13,"column":30}},{"name":"./types/embedded","loc":{"line":127,"column":33}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n/*!\n * Module dependencies.\n */\n\nvar NodeJSDocument = require('./document');\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseError = require('./error');\nvar Schema = require('./schema');\nvar ObjectId = require('./types/objectid');\nvar utils = require('./utils');\nvar ValidationError = MongooseError.ValidationError;\nvar InternalCache = require('./internal');\nvar PromiseProvider = require('./promise_provider');\nvar VersionError = require('./error').VersionError;\n\nvar Embedded;\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = this.schema.options && this.schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = this.schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (!skipInit && obj) {\n    this.init(obj);\n  }\n\n  this.$__registerHooksFromSchema();\n\n  // apply methods\n  for (var m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (var s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\nutils.each(\n    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n      'removeAllListeners', 'addListener'],\n    function(emitterFn) {\n      Document[emitterFn] = function() {\n        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n      };\n    });\n\n/*!\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @deprecated\n * @memberOf Document\n */\n\nDocument.prototype.$__registerHooksFromSchema = function() {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n  var q = _this.schema && _this.schema.callQueue;\n  var toWrapEl;\n  var len;\n  var i;\n  var j;\n  var pointCut;\n  var keys;\n  if (!q.length) {\n    return _this;\n  }\n\n  // we are only interested in 'pre' hooks, and group by point-cut\n  var toWrap = { post: [] };\n  var pair;\n\n  for (i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n      continue;\n    }\n    var args = [].slice.call(pair[1]);\n    pointCut = pair[0] === 'on' ? 'post' : args[0];\n    if (!(pointCut in toWrap)) {\n      toWrap[pointCut] = {post: [], pre: []};\n    }\n    if (pair[0] === 'post') {\n      toWrap[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      toWrap[pointCut].push(args);\n    } else {\n      toWrap[pointCut].pre.push(args);\n    }\n  }\n\n  // 'post' hooks are simpler\n  len = toWrap.post.length;\n  toWrap.post.forEach(function(args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post;\n\n  // 'init' should be synchronous on subdocuments\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.set;\n  }\n\n  keys = Object.keys(toWrap);\n  len = keys.length;\n  for (i = 0; i < len; ++i) {\n    pointCut = keys[i];\n    // this is so we can wrap everything into a promise;\n    var newName = ('$__original_' + pointCut);\n    if (!_this[pointCut]) {\n      continue;\n    }\n    if (_this[pointCut].$isWrapped) {\n      continue;\n    }\n    _this[newName] = _this[pointCut];\n    _this[pointCut] = (function(_newName) {\n      return function wrappedPointCut() {\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== 'function') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don't support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (_this.constructor.$wrapCallback) {\n            fn = _this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      };\n    })(newName);\n    _this[pointCut].$isWrapped = true;\n\n    toWrapEl = toWrap[pointCut];\n    var _len = toWrapEl.pre.length;\n    args;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.pre[j];\n      args[0] = newName;\n      _this.$pre.apply(_this, args);\n    }\n\n    _len = toWrapEl.post.length;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.post[j];\n      args[0] = newName;\n      _this.$post.apply(_this, args);\n    }\n  }\n  return _this;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"},"hash":"78d9578d0dd91f23b2cb9393dd415975"}