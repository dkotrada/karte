{"dependencies":[{"name":"mongodb-core","loc":{"line":5,"column":31}},{"name":"./read_preference","loc":{"line":4,"column":27}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n\"use strict\";\n\nvar MongoError = require('mongodb-core').MongoError,\n  ReadPreference = require('./read_preference'),\n  CoreReadPreference = require('mongodb-core').ReadPreference;\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for(var name in obj) copy[name] = obj[name];\n  return copy;\n}\n\n// Figure out the read preference\nvar getReadPreference = function(options) {\n  var r = null\n  if(options.readPreference) {\n    r = options.readPreference\n  } else {\n    return options;\n  }\n\n  if(r instanceof ReadPreference) {\n    options.readPreference = new CoreReadPreference(r.mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});\n  } else if(typeof r == 'string') {\n    options.readPreference = new CoreReadPreference(r);\n  } else if(r && !(r instanceof ReadPreference) && typeof r == 'object') {\n    var mode = r.mode || r.preference;\n    if (mode && typeof mode == 'string') {\n      options.readPreference = new CoreReadPreference(mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});\n    }\n  }\n\n  return options;\n}\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable:true,\n    get: function() {\n      return value\n    }\n  });\n}\n\nvar formatSortValue = exports.formatSortValue = function(sortDirection) {\n  var value = (\"\" + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\"Illegal sort clause, must be of the form \"\n                    + \"[['field1', '(ascending|descending)'], \"\n                    + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function(sortValue) {\n  var orderBy = {};\n  if(sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if(sortValue.length === 0) {\n      return null;\n    }\n\n    for(var i = 0; i < sortValue.length; i++) {\n      if(sortValue[i].constructor == String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if(sortValue != null && typeof sortValue == 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue == 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\"Illegal sort clause, must be of the form \" +\n      \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName (collectionName) {\n  if('string' !== typeof collectionName) {\n    throw new MongoError(\"collection name must be a String\");\n  }\n\n  if(!collectionName || collectionName.indexOf('..') != -1) {\n    throw new MongoError(\"collection names cannot be empty\");\n  }\n\n  if(collectionName.indexOf('$') != -1 &&\n      collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if(collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if(!!~collectionName.indexOf(\"\\x00\")) {\n    throw new MongoError(\"collection names cannot contain a null character\");\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if(callback == null) return;\n    if(callback) {\n      return value2 ? callback(err, value1, value2) :  callback(err, value1);\n    }\n  } catch(err) {\n    process.nextTick(function() { throw err; });\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({message: msg, driver:true});\n\n  // Get all object keys\n  var keys = typeof error == 'object'\n    ? Object.keys(error)\n    : [];\n\n  for(var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch(err) {\n      // continue\n    }\n  }\n\n  return e;\n}\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if(typeof hint == 'string') {\n    finalHint = hint;\n  } else if(Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if(hint != null && typeof hint == 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if('string' == typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if(Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if('string' == typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if(Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if(isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if(isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join(\"_\"), keys: keys, fieldHash: fieldHash\n  }\n}\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' == Object.prototype.toString.call(arg)\n}\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n}\n\nvar decorateCommand = function(command, options, exclude) {\n  for(var name in options) {\n    if(exclude[name] == null) command[name] = options[name];\n  }\n\n  return command;\n}\n\nvar mergeOptions = function(target, source) {\n  for(var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    'sslCA': 'ca', 'sslCRL': 'crl', 'sslValidate': 'rejectUnauthorized', 'sslKey': 'key',\n    'sslCert': 'cert', 'sslPass': 'passphrase',\n    // SocketTimeout translation options\n    'socketTimeoutMS': 'socketTimeout', 'connectTimeoutMS': 'connectionTimeout',\n    // Replicaset options\n    'replicaSet': 'setName', 'rs_name': 'setName', 'secondaryAcceptableLatencyMS': 'acceptableLatency',\n    'connectWithNoPrimary': 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    'acceptableLatencyMS': 'localThresholdMS'\n  }\n\n  for(var name in source) {\n    if(translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n}\n\nvar filterOptions = function(options, names) {\n  var filterOptions =  {};\n\n  for(var name in options) {\n    if(names.indexOf(name) != -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n}\n\n// Object.assign method or polyfill\nvar assign = Object.assign ? Object.assign : function assign(target) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n  return to;\n}\n\n// Write concern keys\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];\n\n// Merge the write concern options\nvar mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for(var i = 0; i < keys.length; i++) {\n    if(!targetOptions[keys[i]] && sourceOptions[keys[i]] != undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  }\n\n  // No merging of write concern\n  if(!mergeWriteConcern) return targetOptions;\n\n  // Found no write Concern options\n  var found = false;\n  for(var i = 0; i < writeConcernKeys.length; i++) {\n    if(targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if(!found) {\n    for(var i = 0; i < writeConcernKeys.length; i++) {\n      if(sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n}\n\nexports.filterOptions = filterOptions;\nexports.mergeOptions = mergeOptions;\nexports.translateOptions = translateOptions;\nexports.shallowClone = shallowClone;\nexports.getSingleProperty = getSingleProperty;\nexports.checkCollectionName = checkCollectionName;\nexports.toError = toError;\nexports.formattedOrderClause = formattedOrderClause;\nexports.parseIndexOptions = parseIndexOptions;\nexports.normalizeHintField = normalizeHintField;\nexports.handleCallback = handleCallback;\nexports.decorateCommand = decorateCommand;\nexports.isObject = isObject;\nexports.debugOptions = debugOptions;\nexports.MAX_JS_INT = 0x20000000000000;\nexports.assign = assign;\nexports.mergeOptionsAndWriteConcern = mergeOptionsAndWriteConcern;\nexports.getReadPreference = getReadPreference;\n"},"hash":"cdf9d858d449cf97e581d51ade3f8a47"}