{"dependencies":[{"name":"./common","loc":{"line":3,"column":21}},{"name":"../utils","loc":{"line":6,"column":28}},{"name":"mongodb-core","loc":{"line":11,"column":18}},{"name":"../metadata","loc":{"line":10,"column":21}},{"name":"es6-promise","loc":{"line":237,"column":31}}],"generated":{"js":"var global = (1,eval)(\"this\");\n\"use strict\";\n\nvar common = require('./common')\n\t, utils = require('../utils')\n  , toError = require('../utils').toError\n\t, handleCallback = require('../utils').handleCallback\n\t, shallowClone = utils.shallowClone\n  , BulkWriteResult = common.BulkWriteResult\n  , ObjectID = require('mongodb-core').BSON.ObjectID\n  , Define = require('../metadata')\n\t, BSON = require('mongodb-core').BSON\n  , Batch = common.Batch\n  , mergeBatchResults = common.mergeBatchResults;\n\nvar bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,\n\tBSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,\n\tBSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);\n\n/**\n * Create a FindOperatorsOrdered instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @return {FindOperatorsOrdered} a FindOperatorsOrdered instance.\n */\nvar FindOperatorsOrdered = function(self) {\n  this.s = self.s;\n}\n\n/**\n * Add a single update document to the bulk operation\n *\n * @method\n * @param {object} doc update operations\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nFindOperatorsOrdered.prototype.update = function(updateDocument) {\n  // Perform upsert\n  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;\n\n  // Establish the update command\n  var document = {\n      q: this.s.currentOp.selector\n    , u: updateDocument\n    , multi: true\n    , upsert: upsert\n  }\n\n  // Clear out current Op\n  this.s.currentOp = null;\n  // Add the update document to the list\n  return addToOperationsList(this, common.UPDATE, document);\n}\n\n/**\n * Add a single update one document to the bulk operation\n *\n * @method\n * @param {object} doc update operations\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nFindOperatorsOrdered.prototype.updateOne = function(updateDocument) {\n  // Perform upsert\n  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;\n\n  // Establish the update command\n  var document = {\n      q: this.s.currentOp.selector\n    , u: updateDocument\n    , multi: false\n    , upsert: upsert\n  }\n\n  // Clear out current Op\n  this.s.currentOp = null;\n  // Add the update document to the list\n  return addToOperationsList(this, common.UPDATE, document);\n}\n\n/**\n * Add a replace one operation to the bulk operation\n *\n * @method\n * @param {object} doc the new document to replace the existing one with\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nFindOperatorsOrdered.prototype.replaceOne = function(updateDocument) {\n  this.updateOne(updateDocument);\n}\n\n/**\n * Upsert modifier for update bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {FindOperatorsOrdered}\n */\nFindOperatorsOrdered.prototype.upsert = function() {\n  this.s.currentOp.upsert = true;\n  return this;\n}\n\n/**\n * Add a remove one operation to the bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nFindOperatorsOrdered.prototype.deleteOne = function() {\n  // Establish the update command\n  var document = {\n      q: this.s.currentOp.selector\n    , limit: 1\n  }\n\n  // Clear out current Op\n  this.s.currentOp = null;\n  // Add the remove document to the list\n  return addToOperationsList(this, common.REMOVE, document);\n}\n\n// Backward compatibility\nFindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;\n\n/**\n * Add a remove operation to the bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nFindOperatorsOrdered.prototype.delete = function() {\n  // Establish the update command\n  var document = {\n      q: this.s.currentOp.selector\n    , limit: 0\n  }\n\n  // Clear out current Op\n  this.s.currentOp = null;\n  // Add the remove document to the list\n  return addToOperationsList(this, common.REMOVE, document);\n}\n\n// Backward compatibility\nFindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;\n\n// Add to internal list of documents\nvar addToOperationsList = function(_self, docType, document) {\n  // Get the bsonSize\n  var bsonSize = bson.calculateObjectSize(document, {\n\t\tcheckKeys: false,\n\t});\n\n  // Throw error if the doc is bigger than the max BSON size\n  if(bsonSize >= _self.s.maxBatchSizeBytes) {\n\t\tthrow toError(\"document is larger than the maximum size \" + _self.s.maxBatchSizeBytes);\n\t}\n\n  // Create a new batch object if we don't have a current one\n  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);\n\n  // Check if we need to create a new batch\n  if(((_self.s.currentBatchSize + 1) >= _self.s.maxWriteBatchSize)\n    || ((_self.s.currentBatchSizeBytes +  _self.s.currentBatchSizeBytes) >= _self.s.maxBatchSizeBytes)\n    || (_self.s.currentBatch.batchType != docType)) {\n    // Save the batch to the execution stack\n    _self.s.batches.push(_self.s.currentBatch);\n\n    // Create a new batch\n    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);\n\n    // Reset the current size trackers\n    _self.s.currentBatchSize = 0;\n    _self.s.currentBatchSizeBytes = 0;\n  } else {\n    // Update current batch size\n    _self.s.currentBatchSize = _self.s.currentBatchSize + 1;\n    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;\n  }\n\n  if(docType == common.INSERT) {\n    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});\n  }\n\n  // We have an array of documents\n  if(Array.isArray(document)) {\n    throw toError(\"operation passed in cannot be an Array\");\n  } else {\n    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);\n    _self.s.currentBatch.operations.push(document)\n\t\t_self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;\n    _self.s.currentIndex = _self.s.currentIndex + 1;\n  }\n\n  // Return self\n  return _self;\n}\n\n/**\n * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {number} length Get the number of operations in the bulk.\n * @return {OrderedBulkOperation} a OrderedBulkOperation instance.\n */\nfunction OrderedBulkOperation(topology, collection, options) {\n\toptions = options == null ? {} : options;\n\t// TODO Bring from driver information in isMaster\n\tvar executed = false;\n\n\t// Current item\n\tvar currentOp = null;\n\n\t// Handle to the bson serializer, used to calculate running sizes\n\tvar bson = topology.bson;\n\n\t// Namespace for the operation\n  var namespace = collection.collectionName;\n\n  // Set max byte size\n\tvar maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize\n    ? topology.isMasterDoc.maxBsonObjectSize : (1024*1025*16);\n\tvar maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize\n    ? topology.isMasterDoc.maxWriteBatchSize : 1000;\n\n  // Get the write concern\n  var writeConcern = common.writeConcern(shallowClone(options), collection, options);\n\n  // Get the promiseLibrary\n  var promiseLibrary = options.promiseLibrary;\n\n  // No promise library selected fall back\n  if(!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == 'function' ?\n      global.Promise : require('es6-promise').Promise;\n  }\n\n  // Final results\n  var bulkResult = {\n      ok: 1\n    , writeErrors: []\n    , writeConcernErrors: []\n    , insertedIds: []\n    , nInserted: 0\n    , nUpserted: 0\n    , nMatched: 0\n    , nModified: 0\n    , nRemoved: 0\n    , upserted: []\n  };\n\n  // Internal state\n  this.s = {\n    // Final result\n      bulkResult: bulkResult\n    // Current batch state\n    , currentBatch: null\n    , currentIndex: 0\n    , currentBatchSize: 0\n    , currentBatchSizeBytes: 0\n    , batches: []\n    // Write concern\n    , writeConcern: writeConcern\n    // Max batch size options\n    , maxBatchSizeBytes: maxBatchSizeBytes\n    , maxWriteBatchSize: maxWriteBatchSize\n    // Namespace\n    , namespace: namespace\n    // BSON\n    , bson: bson\n    // Topology\n    , topology: topology\n    // Options\n    , options: options\n    // Current operation\n    , currentOp: currentOp\n    // Executed\n    , executed: executed\n    // Collection\n    , collection: collection\n    // Promise Library\n    , promiseLibrary: promiseLibrary\n\t\t// Fundamental error\n\t\t, err: null\n    // Bypass validation\n    , bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false\n  }\n}\n\nvar define = OrderedBulkOperation.define = new Define('OrderedBulkOperation', OrderedBulkOperation, false);\n\nOrderedBulkOperation.prototype.raw = function(op) {\n  var key = Object.keys(op)[0];\n\n  // Set up the force server object id\n  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean'\n    ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;\n\n  // Update operations\n  if((op.updateOne && op.updateOne.q)\n    || (op.updateMany && op.updateMany.q)\n    || (op.replaceOne && op.replaceOne.q)) {\n    op[key].multi = op.updateOne || op.replaceOne ? false : true;\n    return addToOperationsList(this, common.UPDATE, op[key]);\n  }\n\n  // Crud spec update format\n  if(op.updateOne || op.updateMany || op.replaceOne) {\n    var multi = op.updateOne || op.replaceOne ? false : true;\n    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}\n    operation.upsert = op[key].upsert ? true: false;\n\t\tif(op.collation) operation.collation = op.collation;\n    return addToOperationsList(this, common.UPDATE, operation);\n  }\n\n  // Remove operations\n  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {\n    op[key].limit = op.removeOne ? 1 : 0;\n    return addToOperationsList(this, common.REMOVE, op[key]);\n  }\n\n  // Crud spec delete operations, less efficient\n  if(op.deleteOne || op.deleteMany) {\n    var limit = op.deleteOne ? 1 : 0;\n    operation = {q: op[key].filter, limit: limit}\n\t\tif(op.collation) operation.collation = op.collation;\n    return addToOperationsList(this, common.REMOVE, operation);\n  }\n\n  // Insert operations\n  if(op.insertOne && op.insertOne.document == null) {\n    if(forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();\n    return addToOperationsList(this, common.INSERT, op.insertOne);\n  } else if(op.insertOne && op.insertOne.document) {\n    if(forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();\n    return addToOperationsList(this, common.INSERT, op.insertOne.document);\n  }\n\n  if(op.insertMany) {\n    for(var i = 0; i < op.insertMany.length; i++) {\n      if(forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();\n      addToOperationsList(this, common.INSERT, op.insertMany[i]);\n    }\n\n    return;\n  }\n\n  // No valid type of operation\n  throw toError(\"bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany\");\n}\n\n/**\n * Add a single insert document to the bulk operation\n *\n * @param {object} doc the document to insert\n * @throws {MongoError}\n * @return {OrderedBulkOperation}\n */\nOrderedBulkOperation.prototype.insert = function(document) {\n  if(this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();\n  return addToOperationsList(this, common.INSERT, document);\n}\n\n/**\n * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne\n *\n * @method\n * @param {object} selector The selector for the bulk operation.\n * @throws {MongoError}\n * @return {FindOperatorsOrdered}\n */\nOrderedBulkOperation.prototype.find = function(selector) {\n  if (!selector) {\n    throw toError(\"Bulk find operation must specify a selector\");\n  }\n\n  // Save a current selector\n  this.s.currentOp = {\n    selector: selector\n  }\n\n  return new FindOperatorsOrdered(this);\n}\n\nObject.defineProperty(OrderedBulkOperation.prototype, 'length', {\n  enumerable: true,\n  get: function() {\n    return this.s.currentIndex;\n  }\n});\n\n//\n// Execute next write command in a chain\nvar executeCommands = function(self, callback) {\n  if(self.s.batches.length == 0) {\n    return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));\n  }\n\n  // Ordered execution of the command\n  var batch = self.s.batches.shift();\n\n  var resultHandler = function(err, result) {\n\t\t// Error is a driver related error not a bulk op error, terminate\n\t\tif(err && err.driver || err && err.message) {\n\t\t\treturn handleCallback(callback, err);\n\t\t}\n\n    // If we have and error\n    if(err) err.ok = 0;\n    // Merge the results together\n    var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);\n    if(mergeResult != null) {\n      return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));\n    }\n\n    // If we are ordered and have errors and they are\n    // not all replication errors terminate the operation\n    if(self.s.bulkResult.writeErrors.length > 0) {\n      return handleCallback(callback, toError(self.s.bulkResult.writeErrors[0]), new BulkWriteResult(self.s.bulkResult));\n    }\n\n    // Execute the next command in line\n    executeCommands(self, callback);\n  }\n\n  var finalOptions = {ordered: true}\n  if(self.s.writeConcern != null) {\n    finalOptions.writeConcern = self.s.writeConcern;\n  }\n\n\t// Set an operationIf if provided\n\tif(self.operationId) {\n\t\tresultHandler.operationId = self.operationId;\n\t}\n\n\t// Serialize functions\n\tif(self.s.options.serializeFunctions) {\n\t\tfinalOptions.serializeFunctions = true\n\t}\n\n  // Serialize functions\n  if(self.s.options.ignoreUndefined) {\n    finalOptions.ignoreUndefined = true\n  }\n\n  // Is the bypassDocumentValidation options specific\n  if(self.s.bypassDocumentValidation == true) {\n    finalOptions.bypassDocumentValidation = true;\n  }\n\n  try {\n    if(batch.batchType == common.INSERT) {\n      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    } else if(batch.batchType == common.UPDATE) {\n      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    } else if(batch.batchType == common.REMOVE) {\n      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    }\n  } catch(err) {\n    // Force top level error\n    err.ok = 0;\n    // Merge top level error and return\n    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));\n  }\n}\n\n/**\n * The callback format for results\n * @callback OrderedBulkOperation~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {BulkWriteResult} result The bulk write result.\n */\n\n/**\n * Execute the ordered bulk operation\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {OrderedBulkOperation~resultCallback} [callback] The result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\nOrderedBulkOperation.prototype.execute = function(_writeConcern, callback) {\n  var self = this;\n  if (this.s.executed) {\n    var executedError = toError('batch cannot be re-executed');\n    return (typeof callback === 'function') ?\n      callback(executedError, null) : this.s.promiseLibrary.reject(executedError);\n  }\n\n  if (typeof _writeConcern === 'function') {\n    callback = _writeConcern;\n  } else if (_writeConcern && typeof _writeConcern === 'object') {\n    this.s.writeConcern = _writeConcern;\n  }\n\n  // If we have current batch\n  if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch)\n\n  // If we have no operations in the bulk raise an error\n  if (this.s.batches.length == 0) {\n    var emptyBatchError = toError('Invalid Operation, no operations specified');\n    return (typeof callback === 'function') ?\n      callback(emptyBatchError, null) : this.s.promiseLibrary.reject(emptyBatchError);\n  }\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    return executeCommands(this, callback);\n  }\n\n  // Return a Promise\n  return new this.s.promiseLibrary(function(resolve, reject) {\n    executeCommands(self, function(err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n}\n\ndefine.classMethod('execute', {callback: true, promise:false});\n\n/**\n * Returns an unordered batch object\n * @ignore\n */\nvar initializeOrderedBulkOp = function(topology, collection, options) {\n\treturn new OrderedBulkOperation(topology, collection, options);\n}\n\ninitializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;\nmodule.exports = initializeOrderedBulkOp;\nmodule.exports.Bulk = OrderedBulkOperation;\n"},"hash":"f35b77113e5e0b88e968d296224d20b7"}