{"dependencies":[{"name":"../connection/commands","loc":{"line":3,"column":20}},{"name":"../connection/utils","loc":{"line":4,"column":27}},{"name":"util","loc":{"line":5,"column":16}},{"name":"../error","loc":{"line":6,"column":25}},{"name":"./shared","loc":{"line":7,"column":32}}],"generated":{"js":"\"use strict\";\n\nvar Query = require('../connection/commands').Query\n  , retrieveBSON = require('../connection/utils').retrieveBSON\n  , f = require('util').format\n  , MongoError = require('../error')\n  , getReadPreference = require('./shared').getReadPreference;\n\nvar BSON = retrieveBSON(),\n  Long = BSON.Long;\n\nvar WireProtocol = function(legacyWireProtocol) {\n  this.legacyWireProtocol = legacyWireProtocol;\n}\n\n//\n// Execute a write operation\nvar executeWrite = function(pool, bson, type, opsField, ns, ops, options, callback) {\n  if(ops.length == 0) throw new MongoError(\"insert must contain at least one document\");\n  if(typeof options == 'function') {\n    callback = options;\n    options = {};\n    options = options || {};\n  }\n\n  // Split the ns up to get db and collection\n  var p = ns.split(\".\");\n  var d = p.shift();\n  // Options\n  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;\n  var writeConcern = options.writeConcern;\n\n  // return skeleton\n  var writeCommand = {};\n  writeCommand[type] = p.join('.');\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered;\n\n  // Did we specify a write concern\n  if(writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  }\n\n  // If we have collation passed in\n  if(options.collation) {\n    for(var i = 0; i < writeCommand[opsField].length; i++) {\n      if(!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  }\n\n  // Do we have bypassDocumentValidation set, then enable it on the write command\n  if(typeof options.bypassDocumentValidation == 'boolean') {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  // Options object\n  var opts = { command: true };\n  var queryOptions = { checkKeys : false, numberToSkip: 0, numberToReturn: 1 };\n  if(type == 'insert') queryOptions.checkKeys = true;\n  if(typeof options.checkKeys == 'boolean') queryOptions.checkKeys = options.checkKeys;\n\n  // Ensure we support serialization of functions\n  if(options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;\n  // Do not serialize the undefined fields\n  if(options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;\n\n  try {\n    // Create write command\n    var cmd = new Query(bson, f(\"%s.$cmd\", d), writeCommand, queryOptions);\n    // Execute command\n    pool.write(cmd, opts, callback);\n  } catch(err) {\n    callback(err);\n  }\n}\n\n//\n// Needs to support legacy mass insert as well as ordered/unordered legacy\n// emulation\n//\nWireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);\n}\n\nWireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);\n}\n\nWireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);\n}\n\nWireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) {\n  // Build command namespace\n  var parts = ns.split(/\\./);\n  // Command namespace\n  var commandns = f('%s.$cmd', parts.shift());\n  // Create getMore command\n  var killcursorCmd = {\n    killCursors: parts.join('.'),\n    cursors: [cursorId]\n  }\n\n  // Build Query object\n  var query = new Query(bson, commandns, killcursorCmd, {\n      numberToSkip: 0, numberToReturn: -1\n    , checkKeys: false, returnFieldSelector: null\n  });\n\n  // Set query flags\n  query.slaveOk = true;\n\n  // Kill cursor callback\n  var killCursorCallback = function(err, result) {\n    if(err) {\n      if(typeof callback != 'function') return;\n      return callback(err);\n    }\n\n    // Result\n    var r = result.message;\n    // If we have a timed out query or a cursor that was killed\n    if((r.responseFlags & (1 << 0)) != 0) {\n      if(typeof callback != 'function') return;\n      return callback(new MongoError(\"cursor killed or timed out\"), null);\n    }\n\n    if(!Array.isArray(r.documents) || r.documents.length == 0) {\n      if(typeof callback != 'function') return;\n      return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId)));\n    }\n\n    // Return the result\n    if(typeof callback == 'function') {\n      callback(null, r.documents[0]);\n    }\n  }\n\n  // Execute the kill cursor command\n  if(pool && pool.isConnected()) {\n    pool.write(query, {\n      command: true\n    }, killCursorCallback);\n  }\n}\n\nWireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) {\n  options = options || {};\n  // Build command namespace\n  var parts = ns.split(/\\./);\n  // Command namespace\n  var commandns = f('%s.$cmd', parts.shift());\n\n  // Create getMore command\n  var getMoreCmd = {\n    getMore: cursorState.cursorId,\n    collection: parts.join('.'),\n    batchSize: Math.abs(batchSize)\n  }\n\n  if(cursorState.cmd.tailable\n    && typeof cursorState.cmd.maxAwaitTimeMS == 'number') {\n    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;\n  }\n\n  // Build Query object\n  var query = new Query(bson, commandns, getMoreCmd, {\n      numberToSkip: 0, numberToReturn: -1\n    , checkKeys: false, returnFieldSelector: null\n  });\n\n  // Set query flags\n  query.slaveOk = true;\n\n  // Query callback\n  var queryCallback = function(err, result) {\n    if(err) return callback(err);\n    // Get the raw message\n    var r = result.message;\n\n    // If we have a timed out query or a cursor that was killed\n    if((r.responseFlags & (1 << 0)) != 0) {\n      return callback(new MongoError(\"cursor killed or timed out\"), null);\n    }\n\n    // Raw, return all the extracted documents\n    if(raw) {\n      cursorState.documents = r.documents;\n      cursorState.cursorId = r.cursorId;\n      return callback(null, r.documents);\n    }\n\n    // We have an error detected\n    if(r.documents[0].ok == 0) {\n      return callback(MongoError.create(r.documents[0]));\n    }\n\n    // Ensure we have a Long valid cursor id\n    var cursorId = typeof r.documents[0].cursor.id == 'number'\n      ? Long.fromNumber(r.documents[0].cursor.id)\n      : r.documents[0].cursor.id;\n\n    // Set all the values\n    cursorState.documents = r.documents[0].cursor.nextBatch;\n    cursorState.cursorId = cursorId;\n\n    // Return the result\n    callback(null, r.documents[0], r.connection);\n  }\n\n  // Query options\n  var queryOptions = { command: true };\n\n  // If we have a raw query decorate the function\n  if(raw) {\n    queryOptions.raw = raw;\n  }\n\n  // Add the result field needed\n  queryOptions.documentsReturnedIn = 'nextBatch';\n\n  // Check if we need to promote longs\n  if(typeof cursorState.promoteLongs == 'boolean') {\n    queryOptions.promoteLongs = cursorState.promoteLongs;\n  }\n\n  if(typeof cursorState.promoteValues == 'boolean') {\n    queryOptions.promoteValues = cursorState.promoteValues;\n  }\n\n  if(typeof cursorState.promoteBuffers == 'boolean') {\n    queryOptions.promoteBuffers = cursorState.promoteBuffers;\n  }\n\n  // Write out the getMore command\n  connection.write(query, queryOptions, queryCallback);\n}\n\nWireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {\n  options = options || {}\n  // Check if this is a wire protocol command or not\n  var wireProtocolCommand = typeof options.wireProtocolCommand == 'boolean' ? options.wireProtocolCommand : true;\n\n  // Establish type of command\n  if(cmd.find && wireProtocolCommand) {\n    // Create the find command\n    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options)\n    // Mark the cmd as virtual\n    cmd.virtual = false;\n    // Signal the documents are in the firstBatch value\n    query.documentsReturnedIn = 'firstBatch';\n    // Return the query\n    return query;\n  } else if(cursorState.cursorId != null) {\n    return;\n  } else if(cmd) {\n    return setupCommand(bson, ns, cmd, cursorState, topology, options);\n  } else {\n    throw new MongoError(f(\"command %s does not return a cursor\", JSON.stringify(cmd)));\n  }\n}\n\n// // Command\n// {\n//     find: ns\n//   , query: <object>\n//   , limit: <n>\n//   , fields: <object>\n//   , skip: <n>\n//   , hint: <string>\n//   , explain: <boolean>\n//   , snapshot: <boolean>\n//   , batchSize: <n>\n//   , returnKey: <boolean>\n//   , maxScan: <n>\n//   , min: <n>\n//   , max: <n>\n//   , showDiskLoc: <boolean>\n//   , comment: <string>\n//   , maxTimeMS: <n>\n//   , raw: <boolean>\n//   , readPreference: <ReadPreference>\n//   , tailable: <boolean>\n//   , oplogReplay: <boolean>\n//   , noCursorTimeout: <boolean>\n//   , awaitdata: <boolean>\n//   , exhaust: <boolean>\n//   , partial: <boolean>\n// }\n\n// FIND/GETMORE SPEC\n// {\n//     “find”: <string>,\n//     “filter”: { ... },\n//     “sort”: { ... },\n//     “projection”: { ... },\n//     “hint”: { ... },\n//     “skip”: <int>,\n//     “limit”: <int>,\n//     “batchSize”: <int>,\n//     “singleBatch”: <bool>,\n//     “comment”: <string>,\n//     “maxScan”: <int>,\n//     “maxTimeMS”: <int>,\n//     “max”: { ... },\n//     “min”: { ... },\n//     “returnKey”: <bool>,\n//     “showRecordId”: <bool>,\n//     “snapshot”: <bool>,\n//     “tailable”: <bool>,\n//     “oplogReplay”: <bool>,\n//     “noCursorTimeout”: <bool>,\n//     “awaitData”: <bool>,\n//     “partial”: <bool>,\n//     “$readPreference”: { ... }\n// }\n\n//\n// Execute a find command\nvar executeFindCommand = function(bson, ns, cmd, cursorState, topology, options) {\n  // Ensure we have at least some options\n  options = options || {};\n  // Get the readPreference\n  var readPreference = getReadPreference(cmd, options);\n  // Set the optional batchSize\n  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;\n\n  // Build command namespace\n  var parts = ns.split(/\\./);\n  // Command namespace\n  var commandns = f('%s.$cmd', parts.shift());\n\n  // Build actual find command\n  var findCmd = {\n    find: parts.join('.')\n  };\n\n  // I we provided a filter\n  if(cmd.query) {\n    // Check if the user is passing in the $query parameter\n    if(cmd.query['$query']) {\n      findCmd.filter = cmd.query['$query'];\n    } else {\n      findCmd.filter = cmd.query;\n    }\n  }\n\n  // Sort value\n  var sortValue = cmd.sort;\n\n  // Handle issue of sort being an Array\n  if(Array.isArray(sortValue)) {\n    var sortObject = {};\n\n    if(sortValue.length > 0 && !Array.isArray(sortValue[0])) {\n      var sortDirection = sortValue[1];\n      // Translate the sort order text\n      if(sortDirection == 'asc') {\n        sortDirection = 1;\n      } else if(sortDirection == 'desc') {\n        sortDirection = -1;\n      }\n\n      // Set the sort order\n      sortObject[sortValue[0]] = sortDirection;\n    } else {\n      for(var i = 0; i < sortValue.length; i++) {\n        sortDirection = sortValue[i][1];\n        // Translate the sort order text\n        if(sortDirection == 'asc') {\n          sortDirection = 1;\n        } else if(sortDirection == 'desc') {\n          sortDirection = -1;\n        }\n\n        // Set the sort order\n        sortObject[sortValue[i][0]] = sortDirection;\n      }\n    }\n\n    sortValue = sortObject;\n  }\n\n  // Add sort to command\n  if(cmd.sort) findCmd.sort = sortValue;\n  // Add a projection to the command\n  if(cmd.fields) findCmd.projection = cmd.fields;\n  // Add a hint to the command\n  if(cmd.hint) findCmd.hint = cmd.hint;\n  // Add a skip\n  if(cmd.skip) findCmd.skip = cmd.skip;\n  // Add a limit\n  if(cmd.limit) findCmd.limit = cmd.limit;\n\n  // Check if we wish to have a singleBatch\n  if(cmd.limit < 0) {\n    findCmd.limit = Math.abs(cmd.limit);\n    findCmd.singleBatch = true;\n  }\n\n  // Add a batchSize\n  if(typeof cmd.batchSize == 'number') {\n    if (cmd.batchSize < 0) {\n      if (cmd.limit != 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {\n        findCmd.limit = Math.abs(cmd.batchSize);\n      }\n\n      findCmd.singleBatch = true;\n    }\n\n    findCmd.batchSize = Math.abs(cmd.batchSize);\n  }\n\n  // If we have comment set\n  if(cmd.comment) findCmd.comment = cmd.comment;\n\n  // If we have maxScan\n  if(cmd.maxScan) findCmd.maxScan = cmd.maxScan;\n\n  // If we have maxTimeMS set\n  if(cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;\n\n  // If we have min\n  if(cmd.min) findCmd.min = cmd.min;\n\n  // If we have max\n  if(cmd.max) findCmd.max = cmd.max;\n\n  // If we have returnKey set\n  if(cmd.returnKey) findCmd.returnKey = cmd.returnKey;\n\n  // If we have showDiskLoc set\n  if(cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc;\n\n  // If we have snapshot set\n  if(cmd.snapshot) findCmd.snapshot = cmd.snapshot;\n\n  // If we have tailable set\n  if(cmd.tailable) findCmd.tailable = cmd.tailable;\n\n  // If we have oplogReplay set\n  if(cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;\n\n  // If we have noCursorTimeout set\n  if(cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;\n\n  // If we have awaitData set\n  if(cmd.awaitData) findCmd.awaitData = cmd.awaitData;\n  if(cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;\n\n  // If we have partial set\n  if(cmd.partial) findCmd.partial = cmd.partial;\n\n  // If we have collation passed in\n  if(cmd.collation) findCmd.collation = cmd.collation;\n\n  // If we have explain, we need to rewrite the find command\n  // to wrap it in the explain command\n  if(cmd.explain) {\n    findCmd = {\n      explain: findCmd\n    }\n  }\n\n  // Did we provide a readConcern\n  if(cmd.readConcern) findCmd.readConcern = cmd.readConcern;\n\n  // Set up the serialize and ignoreUndefined fields\n  var serializeFunctions = typeof options.serializeFunctions == 'boolean'\n    ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'\n    ? options.ignoreUndefined : false;\n\n  // We have a Mongos topology, check if we need to add a readPreference\n  if(topology.type == 'mongos'\n    && readPreference\n    && readPreference.preference != 'primary') {\n    findCmd = {\n      '$query': findCmd,\n      '$readPreference': readPreference.toJSON()\n    };\n  }\n\n  // Build Query object\n  var query = new Query(bson, commandns, findCmd, {\n      numberToSkip: 0, numberToReturn: 1\n    , checkKeys: false, returnFieldSelector: null\n    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined\n  });\n\n  // Set query flags\n  query.slaveOk = readPreference.slaveOk();\n\n  // Return the query\n  return query;\n}\n\n//\n// Set up a command cursor\nvar setupCommand = function(bson, ns, cmd, cursorState, topology, options) {\n  // Set empty options object\n  options = options || {}\n  // Get the readPreference\n  var readPreference = getReadPreference(cmd, options);\n\n  // Final query\n  var finalCmd = {};\n  for(var name in cmd) {\n    finalCmd[name] = cmd[name];\n  }\n\n  // Build command namespace\n  var parts = ns.split(/\\./);\n\n  // Serialize functions\n  var serializeFunctions = typeof options.serializeFunctions == 'boolean'\n    ? options.serializeFunctions : false;\n\n  // Set up the serialize and ignoreUndefined fields\n  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'\n    ? options.ignoreUndefined : false;\n\n  // We have a Mongos topology, check if we need to add a readPreference\n  if(topology.type == 'mongos'\n    && readPreference\n    && readPreference.preference != 'primary') {\n    finalCmd = {\n      '$query': finalCmd,\n      '$readPreference': readPreference.toJSON()\n    };\n  }\n\n  // Build Query object\n  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {\n      numberToSkip: 0, numberToReturn: -1\n    , checkKeys: false, serializeFunctions: serializeFunctions\n    , ignoreUndefined: ignoreUndefined\n  });\n\n  // Set query flags\n  query.slaveOk = readPreference.slaveOk();\n\n  // Return the query\n  return query;\n}\n\nmodule.exports = WireProtocol;\n"},"hash":"8b1983031ecb76b4a2f33e6d0e13a428"}