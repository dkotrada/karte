{"dependencies":[{"name":"mongodb-core","loc":{"line":3,"column":25}},{"name":"util","loc":{"line":4,"column":16}}],"generated":{"js":"\"use strict\";\n\nvar MongoError = require('mongodb-core').MongoError\n  , f = require('util').format;\n\n// The store of ops\nvar Store = function(topology, storeOptions) {\n  var self = this;\n  var storedOps = [];\n  storeOptions = storeOptions || {force:false, bufferMaxEntries: -1}\n\n  // Internal state\n  this.s = {\n      storedOps: storedOps\n    , storeOptions: storeOptions\n    , topology: topology\n  }\n\n  Object.defineProperty(this, 'length', {\n    enumerable:true, get: function() { return self.s.storedOps.length; }\n  });\n}\n\nStore.prototype.add = function(opType, ns, ops, options, callback) {\n  if(this.s.storeOptions.force) {\n    return callback(MongoError.create({message: \"db closed by application\", driver:true}));\n  }\n\n  if(this.s.storeOptions.bufferMaxEntries == 0) {\n    return callback(MongoError.create({message: f(\"no connection available for operation and number of stored operation > %s\", this.s.storeOptions.bufferMaxEntries), driver:true }));\n  }\n\n  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {\n    while(this.s.storedOps.length > 0) {\n      var op = this.s.storedOps.shift();\n      op.c(MongoError.create({message: f(\"no connection available for operation and number of stored operation > %s\", this.s.storeOptions.bufferMaxEntries), driver:true }));\n    }\n\n    return;\n  }\n\n  this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback})\n}\n\nStore.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {\n  if(this.s.storeOptions.force) {\n    return callback(MongoError.create({message: \"db closed by application\", driver:true }));\n  }\n\n  if(this.s.storeOptions.bufferMaxEntries == 0) {\n    return callback(MongoError.create({message: f(\"no connection available for operation and number of stored operation > %s\", this.s.storeOptions.bufferMaxEntries), driver:true }));\n  }\n\n  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {\n    while(this.s.storedOps.length > 0) {\n      var op = this.s.storedOps.shift();\n      op.c(MongoError.create({message: f(\"no connection available for operation and number of stored operation > %s\", this.s.storeOptions.bufferMaxEntries), driver:true }));\n    }\n\n    return;\n  }\n\n  this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback})\n}\n\nStore.prototype.flush = function(err) {\n  while(this.s.storedOps.length > 0) {\n    this.s.storedOps.shift().c(err || MongoError.create({message: f(\"no connection available for operation\"), driver:true }));\n  }\n}\n\nvar primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];\nvar secondaryOptions = ['secondary', 'secondaryPreferred'];\n\nStore.prototype.execute = function(options) {\n  options = options || {};\n  // Get current ops\n  var ops = this.s.storedOps;\n  // Reset the ops\n  this.s.storedOps = [];\n\n  // Unpack options\n  var executePrimary = typeof options.executePrimary === 'boolean'\n    ? options.executePrimary : true;\n  var executeSecondary = typeof options.executeSecondary === 'boolean'\n    ? options.executeSecondary : true;\n\n  // Execute all the stored ops\n  while(ops.length > 0) {\n    var op = ops.shift();\n\n    if(op.t == 'cursor') {\n      if(executePrimary && executeSecondary) {\n        op.o[op.m].apply(op.o, op.p);\n      } else if(executePrimary && op.o.options\n        && op.o.options.readPreference\n        && primaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {\n          op.o[op.m].apply(op.o, op.p);\n      } else if(!executePrimary && executeSecondary && op.o.options\n        && op.o.options.readPreference\n        && secondaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {\n          op.o[op.m].apply(op.o, op.p);\n      }\n    } else if(op.t == 'auth') {\n      this.s.topology[op.t].apply(this.s.topology, op.o);\n    } else {\n      if(executePrimary && executeSecondary) {\n        this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      } else if(executePrimary && op.op && op.op.readPreference\n        && primaryOptions.indexOf(op.op.readPreference.mode) != -1) {\n          this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      } else if(!executePrimary && executeSecondary && op.op && op.op.readPreference\n        && secondaryOptions.indexOf(op.op.readPreference.mode) != -1) {\n          this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      }\n    }\n  }\n}\n\nStore.prototype.all = function() {\n  return this.s.storedOps;\n}\n\n// Server capabilities\nvar ServerCapabilities = function(ismaster) {\n  var setup_get_property = function(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true\n      , get: function () { return value; }\n    });\n  }\n\n  // Capabilities\n  var aggregationCursor = false;\n  var writeCommands = false;\n  var textSearch = false;\n  var authCommands = false;\n  var listCollections = false;\n  var listIndexes = false;\n  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;\n  var commandsTakeWriteConcern = false;\n  var commandsTakeCollation = false;\n\n  if(ismaster.minWireVersion >= 0) {\n    textSearch = true;\n  }\n\n  if(ismaster.maxWireVersion >= 1) {\n    aggregationCursor = true;\n    authCommands = true;\n  }\n\n  if(ismaster.maxWireVersion >= 2) {\n    writeCommands = true;\n  }\n\n  if(ismaster.maxWireVersion >= 3) {\n    listCollections = true;\n    listIndexes = true;\n  }\n\n  if(ismaster.maxWireVersion >= 5) {\n    commandsTakeWriteConcern = true;\n    commandsTakeCollation = true;\n  }\n\n  // If no min or max wire version set to 0\n  if(ismaster.minWireVersion == null) {\n    ismaster.minWireVersion = 0;\n  }\n\n  if(ismaster.maxWireVersion == null) {\n    ismaster.maxWireVersion = 0;\n  }\n\n  // Map up read only parameters\n  setup_get_property(this, \"hasAggregationCursor\", aggregationCursor);\n  setup_get_property(this, \"hasWriteCommands\", writeCommands);\n  setup_get_property(this, \"hasTextSearch\", textSearch);\n  setup_get_property(this, \"hasAuthCommands\", authCommands);\n  setup_get_property(this, \"hasListCollectionsCommand\", listCollections);\n  setup_get_property(this, \"hasListIndexesCommand\", listIndexes);\n  setup_get_property(this, \"minWireVersion\", ismaster.minWireVersion);\n  setup_get_property(this, \"maxWireVersion\", ismaster.maxWireVersion);\n  setup_get_property(this, \"maxNumberOfDocsInBatch\", maxNumberOfDocsInBatch);\n  setup_get_property(this, \"commandsTakeWriteConcern\", commandsTakeWriteConcern);\n  setup_get_property(this, \"commandsTakeCollation\", commandsTakeCollation);\n}\n\nexports.Store = Store;\nexports.ServerCapabilities = ServerCapabilities;\n"},"hash":"6dc459643997fe65d3b5ca3c33d99118"}