{"dependencies":[{"name":"./helpers","loc":{"line":6,"column":27}},{"name":"../array","loc":{"line":17,"column":28}}],"generated":{"js":"/*!\n * Module requirements.\n */\n\nvar castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\nvar castToNumber = require('./helpers').castToNumber;\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  var SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    var type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(function(arr) {\n      if (!Array.isArray(arr)) {\n        var msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach(function(v, i) {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach(function(item, i) {\n      if (Array.isArray(item)) {\n        item.forEach(function(v, j) {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  var geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n"},"hash":"0c1a00aa07a20f853e16fa1d0e3a6b75"}