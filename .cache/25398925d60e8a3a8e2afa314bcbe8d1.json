{"dependencies":[{"name":"events","loc":{"line":3,"column":27}},{"name":"util","loc":{"line":9,"column":16}},{"name":"mongodb-core","loc":{"line":13,"column":25}},{"name":"./cursor","loc":{"line":6,"column":21}},{"name":"./aggregation_cursor","loc":{"line":7,"column":32}},{"name":"./command_cursor","loc":{"line":8,"column":28}},{"name":"./topology_base","loc":{"line":11,"column":20}},{"name":"./metadata","loc":{"line":12,"column":21}},{"name":"./utils","loc":{"line":18,"column":32}},{"name":"os","loc":{"line":19,"column":17}},{"name":"../package.json","loc":{"line":22,"column":28}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n\"use strict\";\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('util').inherits\n  , CServer = require('mongodb-core').Server\n  , Cursor = require('./cursor')\n  , AggregationCursor = require('./aggregation_cursor')\n  , CommandCursor = require('./command_cursor')\n  , f = require('util').format\n  , ServerCapabilities = require('./topology_base').ServerCapabilities\n  , Store = require('./topology_base').Store\n  , Define = require('./metadata')\n  , MongoError = require('mongodb-core').MongoError\n  , MAX_JS_INT = require('./utils').MAX_JS_INT\n  , translateOptions = require('./utils').translateOptions\n  , filterOptions = require('./utils').filterOptions\n  , mergeOptions = require('./utils').mergeOptions\n  , getReadPreference = require('./utils').getReadPreference\n  , os = require('os');\n\n// Get package.json variable\nvar driverVersion = require('../package.json').version;\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\nvar type = os.type();\nvar name = process.platform;\nvar architecture = process.arch;\nvar release = os.release();\n\n/**\n * @fileOverview The **Server** class is a class that represents a single server topology and is\n * used to construct connections.\n *\n * **Server Should not be used, use MongoClient.connect**\n * @example\n * var Db = require('mongodb').Db,\n *   Server = require('mongodb').Server,\n *   test = require('assert');\n * // Connect using single Server\n * var db = new Db('test', new Server('localhost', 27017););\n * db.open(function(err, db) {\n *   // Get an additional db\n *   db.close();\n * });\n */\n\n // Allowed parameters\n var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS'\n   , 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'ciphers', 'ecdhCurve'\n   , 'sslCA', 'sslCRL', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'\n   , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'\n   , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'family'\n   , 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring'\n   , 'appname', 'domainsEnabled'\n   , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];\n\n/**\n * Creates a new Server instance\n * @class\n * @deprecated\n * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.\n * @param {number} [port] The server port if IP4.\n * @param {object} [options=null] Optional settings.\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL=null] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.autoReconnect=true] Reconnect on error or timeout.\n * @param {object} [options.socketOptions=null] Socket options\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.\n * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting\n * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Triggers the server instance to call ismaster\n * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @property {string} parserType the parser type used (c++ or js).\n * @return {Server} a Server instance.\n */\nvar Server = function(host, port, options) {\n  options = options || {};\n  if(!(this instanceof Server)) return new Server(host, port, options);\n  EventEmitter.call(this);\n  var self = this;\n\n  // Filter the options\n  options = filterOptions(options, legalOptionNames);\n\n  // Stored options\n  var storeOptions = {\n      force: false\n    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT\n  }\n\n  // Shared global store\n  var store = options.store || new Store(self, storeOptions);\n\n  // Detect if we have a socket connection\n  if(host.indexOf('\\/') != -1) {\n    if(port != null && typeof port == 'object') {\n      options = port;\n      port = null;\n    }\n  } else if(port == null) {\n    throw MongoError.create({message: 'port must be specified', driver:true});\n  }\n\n  // Get the reconnect option\n  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;\n  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;\n\n  // Clone options\n  var clonedOptions = mergeOptions({}, {\n    host: host, port: port, disconnectHandler: store,\n    cursorFactory: Cursor,\n    reconnect: reconnect,\n    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,\n    size: typeof options.poolSize == 'number' ? options.poolSize : 5\n  });\n\n  // Translate any SSL options and other connectivity options\n  clonedOptions = translateOptions(clonedOptions, options);\n\n  // Socket options\n  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0\n    ? options.socketOptions : options;\n\n  // Translate all the options to the mongodb-core ones\n  clonedOptions = translateOptions(clonedOptions, socketOptions);\n  if(typeof clonedOptions.keepAlive == 'number') {\n    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;\n    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;\n  }\n\n  // Build default client information\n  this.clientInfo = {\n    driver: {\n      name: \"nodejs\",\n      version: driverVersion\n    },\n    os: {\n      type: type,\n      name: name,\n      architecture: architecture,\n      version: release\n    },\n    platform: nodejsversion\n  }\n\n  // Build default client information\n  clonedOptions.clientInfo = this.clientInfo;\n  // Do we have an application specific string\n  if(options.appname) {\n    clonedOptions.clientInfo.application = { name: options.appname };\n  }\n\n  // Create an instance of a server instance from mongodb-core\n  var server = new CServer(clonedOptions);\n\n  // Define the internal properties\n  this.s = {\n    // Create an instance of a server instance from mongodb-core\n      server: server\n    // Server capabilities\n    , sCapabilities: null\n    // Cloned options\n    , clonedOptions: clonedOptions\n    // Reconnect\n    , reconnect: clonedOptions.reconnect\n    // Emit error\n    , emitError: clonedOptions.emitError\n    // Pool size\n    , poolSize: clonedOptions.size\n    // Store Options\n    , storeOptions: storeOptions\n    // Store\n    , store: store\n    // Host\n    , host: host\n    // Port\n    , port: port\n    // Options\n    , options: options\n  }\n}\n\ninherits(Server, EventEmitter);\n\nvar define = Server.define = new Define('Server', Server, false);\n\n// BSON property\nObject.defineProperty(Server.prototype, 'bson', {\n  enumerable: true, get: function() {\n    return this.s.server.s.bson;\n  }\n});\n\n// Last ismaster\nObject.defineProperty(Server.prototype, 'isMasterDoc', {\n  enumerable:true, get: function() {\n    return this.s.server.lastIsMaster();\n  }\n});\n\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable:true, get: function() {\n    return this.s.server.parserType;\n  }\n});\n\n// Last ismaster\nObject.defineProperty(Server.prototype, 'poolSize', {\n  enumerable:true, get: function() { return this.s.server.connections().length; }\n});\n\nObject.defineProperty(Server.prototype, 'autoReconnect', {\n  enumerable:true, get: function() { return this.s.reconnect; }\n});\n\nObject.defineProperty(Server.prototype, 'host', {\n  enumerable:true, get: function() { return this.s.host; }\n});\n\nObject.defineProperty(Server.prototype, 'port', {\n  enumerable:true, get: function() { return this.s.port; }\n});\n\n// Connect\nServer.prototype.connect = function(db, _options, callback) {\n  var self = this;\n  if('function' === typeof _options) callback = _options, _options = {};\n  if(_options == null) _options = {};\n  if(!('function' === typeof callback)) callback = null;\n  self.s.options = _options;\n\n  // Update bufferMaxEntries\n  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;\n\n  // Error handler\n  var connectErrorHandler = function() {\n    return function(err) {\n      // Remove all event handlers\n      var events = ['timeout', 'error', 'close'];\n      events.forEach(function(e) {\n        self.s.server.removeListener(e, connectHandlers[e]);\n      });\n\n      self.s.server.removeListener('connect', connectErrorHandler);\n\n      // Try to callback\n      try {\n        callback(err);\n      } catch(err) {\n        process.nextTick(function() { throw err; })\n      }\n    }\n  }\n\n  // Actual handler\n  var errorHandler = function(event) {\n    return function(err) {\n      if(event != 'error') {\n        self.emit(event, err);\n      }\n    }\n  }\n\n  // Error handler\n  var reconnectHandler = function() {\n    self.emit('reconnect', self);\n    self.s.store.execute();\n  }\n\n  // Reconnect failed\n  var reconnectFailedHandler = function(err) {\n    self.emit('reconnectFailed', err);\n    self.s.store.flush(err);\n  }\n\n  // Destroy called on topology, perform cleanup\n  var destroyHandler = function() {\n    self.s.store.flush();\n  }\n\n  // relay the event\n  var relay = function(event) {\n    return function(t, server) {\n      self.emit(event, t, server);\n    }\n  }\n\n  // Connect handler\n  var connectHandler = function() {\n    // Clear out all the current handlers left over\n    [\"timeout\", \"error\", \"close\", 'destroy'].forEach(function(e) {\n      self.s.server.removeAllListeners(e);\n    });\n\n    // Set up listeners\n    self.s.server.on('timeout', errorHandler('timeout'));\n    self.s.server.once('error', errorHandler('error'));\n    self.s.server.on('close', errorHandler('close'));\n    // Only called on destroy\n    self.s.server.on('destroy', destroyHandler);\n\n    // Emit open event\n    self.emit('open', null, self);\n\n    // Return correctly\n    try {\n      callback(null, self);\n    } catch(err) {\n      console.log(err.stack)\n      process.nextTick(function() { throw err; })\n    }\n  }\n\n  // Set up listeners\n  var connectHandlers = {\n    timeout: connectErrorHandler('timeout'),\n    error: connectErrorHandler('error'),\n    close: connectErrorHandler('close')\n  };\n\n  // Clear out all the current handlers left over\n  [\"timeout\", \"error\", \"close\", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',\n    'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',\n    'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) {\n    self.s.server.removeAllListeners(e);\n  });\n\n  // Add the event handlers\n  self.s.server.once('timeout', connectHandlers.timeout);\n  self.s.server.once('error', connectHandlers.error);\n  self.s.server.once('close', connectHandlers.close);\n  self.s.server.once('connect', connectHandler);\n  // Reconnect server\n  self.s.server.on('reconnect', reconnectHandler);\n  self.s.server.on('reconnectFailed', reconnectFailedHandler);\n\n  // Set up SDAM listeners\n  self.s.server.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n  self.s.server.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n  self.s.server.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n  self.s.server.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n  self.s.server.on('serverOpening', relay('serverOpening'));\n  self.s.server.on('serverClosed', relay('serverClosed'));\n  self.s.server.on('topologyOpening', relay('topologyOpening'));\n  self.s.server.on('topologyClosed', relay('topologyClosed'));\n  self.s.server.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n  self.s.server.on('attemptReconnect', relay('attemptReconnect'));\n  self.s.server.on('monitoring', relay('monitoring'));\n\n  // Start connection\n  self.s.server.connect(_options);\n}\n\n// Server capabilities\nServer.prototype.capabilities = function() {\n  if(this.s.sCapabilities) return this.s.sCapabilities;\n  if(this.s.server.lastIsMaster() == null) return null;\n  this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());\n  return this.s.sCapabilities;\n}\n\ndefine.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});\n\n// Command\nServer.prototype.command = function(ns, cmd, options, callback) {\n  this.s.server.command(ns, cmd, getReadPreference(options), callback);\n}\n\ndefine.classMethod('command', {callback: true, promise:false});\n\n// Insert\nServer.prototype.insert = function(ns, ops, options, callback) {\n  this.s.server.insert(ns, ops, options, callback);\n}\n\ndefine.classMethod('insert', {callback: true, promise:false});\n\n// Update\nServer.prototype.update = function(ns, ops, options, callback) {\n  this.s.server.update(ns, ops, options, callback);\n}\n\ndefine.classMethod('update', {callback: true, promise:false});\n\n// Remove\nServer.prototype.remove = function(ns, ops, options, callback) {\n  this.s.server.remove(ns, ops, options, callback);\n}\n\ndefine.classMethod('remove', {callback: true, promise:false});\n\n// IsConnected\nServer.prototype.isConnected = function() {\n  return this.s.server.isConnected();\n}\n\nServer.prototype.isDestroyed = function() {\n  return this.s.server.isDestroyed();\n}\n\ndefine.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});\n\n// Insert\nServer.prototype.cursor = function(ns, cmd, options) {\n  options.disconnectHandler = this.s.store;\n  return this.s.server.cursor(ns, cmd, options);\n}\n\ndefine.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});\n\nServer.prototype.lastIsMaster = function() {\n  return this.s.server.lastIsMaster();\n}\n\n/**\n * Unref all sockets\n * @method\n */\nServer.prototype.unref = function() {\n  this.s.server.unref();\n}\n\nServer.prototype.close = function(forceClosed) {\n  this.s.server.destroy();\n  // We need to wash out all stored processes\n  if(forceClosed == true) {\n    this.s.storeOptions.force = forceClosed;\n    this.s.store.flush();\n  }\n}\n\ndefine.classMethod('close', {callback: false, promise:false});\n\nServer.prototype.auth = function() {\n  var args = Array.prototype.slice.call(arguments, 0);\n  this.s.server.auth.apply(this.s.server, args);\n}\n\ndefine.classMethod('auth', {callback: true, promise:false});\n\nServer.prototype.logout = function() {\n  var args = Array.prototype.slice.call(arguments, 0);\n  this.s.server.logout.apply(this.s.server, args);\n}\n\ndefine.classMethod('logout', {callback: true, promise:false});\n\n/**\n * All raw connections\n * @method\n * @return {array}\n */\nServer.prototype.connections = function() {\n  return this.s.server.connections();\n}\n\ndefine.classMethod('connections', {callback: false, promise:false, returns:[Array]});\n\n/**\n * Server connect event\n *\n * @event Server#connect\n * @type {object}\n */\n\n/**\n * Server close event\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server reconnect event\n *\n * @event Server#reconnect\n * @type {object}\n */\n\n/**\n * Server error event\n *\n * @event Server#error\n * @type {MongoError}\n */\n\n/**\n * Server timeout event\n *\n * @event Server#timeout\n * @type {object}\n */\n\n/**\n * Server parseError event\n *\n * @event Server#parseError\n * @type {object}\n */\n\nmodule.exports = Server;\n"},"hash":"4f8241f518e633920c1f666a214a582e"}