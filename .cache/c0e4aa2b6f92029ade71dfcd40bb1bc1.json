{"dependencies":[{"name":"util","loc":{"line":8,"column":16}},{"name":"events","loc":{"line":4,"column":27}},{"name":"net","loc":{"line":5,"column":18}},{"name":"tls","loc":{"line":6,"column":18}},{"name":"crypto","loc":{"line":7,"column":21}},{"name":"./utils","loc":{"line":9,"column":27}},{"name":"./commands","loc":{"line":10,"column":23}},{"name":"../error","loc":{"line":11,"column":25}},{"name":"./logger","loc":{"line":12,"column":21}},{"name":"buffer"}],"generated":{"js":"var Buffer = require(\"buffer\").Buffer;\n\"use strict\";\n\nvar inherits = require('util').inherits\n  , EventEmitter = require('events').EventEmitter\n  , net = require('net')\n  , tls = require('tls')\n  , crypto = require('crypto')\n  , f = require('util').format\n  , debugOptions = require('./utils').debugOptions\n  , Response = require('./commands').Response\n  , MongoError = require('../error')\n  , Logger = require('./logger');\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'\n  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert'\n  , 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nvar connectionAccounting = false;\nvar connections = {};\n\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.family=null] IP version for DNS lookup, passed down to Node's [`dns.lookup()` function](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback). If set to `6`, will only look for ipv6 addresses.\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\nvar Connection = function(messageHandler, options) {\n  // Add event listener\n  EventEmitter.call(this);\n  // Set empty if no options passed\n  this.options = options || {};\n  // Identification information\n  this.id = _id++;\n  // Logger instance\n  this.logger = Logger('Connection', options);\n  // No bson parser passed in\n  if(!options.bson) throw new Error(\"must pass in valid bson parser\");\n  // Get bson parser\n  this.bson = options.bson;\n  // Grouping tag used for debugging purposes\n  this.tag = options.tag;\n  // Message handler\n  this.messageHandler = messageHandler;\n\n  // Max BSON message size\n  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);\n  // Debug information\n  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));\n\n  // Default options\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.family = typeof options.family == 'number' ? options.family : void 0;\n  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay == 'number' \n    ? options.keepAliveInitialDelay : 300000;\n  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = typeof options.connectionTimeout == 'number'\n    ? options.connectionTimeout : 30000;\n  this.socketTimeout = typeof options.socketTimeout == 'number'\n    ? options.socketTimeout : 360000;\n\n  // Is the keepAliveInitialDelay > socketTimeout set it to half of socketTimeout\n  if(this.keepAliveInitialDelay > this.socketTimeout) {\n    this.keepAliveInitialDelay = Math.round(this.socketTimeout/2);\n  }\n\n  // If connection was destroyed\n  this.destroyed = false;\n\n  // Check if we have a domain socket\n  this.domainSocket = this.host.indexOf('\\/') != -1;\n\n  // Serialize commands using function\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';\n\n  // SSL options\n  this.ca = options.ca || null;\n  this.crl = options.crl || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ciphers = options.ciphers || null;\n  this.ecdhCurve = options.ecdhCurve || null;\n  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;\n  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean'\n    || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true;\n\n  // If ssl not enabled\n  if(!this.ssl) this.rejectUnauthorized = false;\n\n  // Response options\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers: false\n  }\n\n  // Flushing\n  this.flushing = false;\n  this.queue = [];\n\n  // Internal state\n  this.connection = null;\n  this.writeStream = null;\n\n  // Create hash method\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port));\n\n  // Create a hash name\n  this.hashedName = hash.digest('hex');\n\n  // All operations in flight on the connection\n  this.workItems = [];\n}\n\ninherits(Connection, EventEmitter);\n\nConnection.prototype.setSocketTimeout = function(value) {\n  if(this.connection) {\n    this.connection.setTimeout(value);\n  }\n}\n\nConnection.prototype.resetSocketTimeout = function() {\n  if(this.connection) {\n    this.connection.setTimeout(this.socketTimeout);\n  }\n}\n\nConnection.enableConnectionAccounting = function() {\n  connectionAccounting = true;\n  connections = {};\n}\n\nConnection.disableConnectionAccounting = function() {\n  connectionAccounting = false;\n}\n\nConnection.connections = function() {\n  return connections;\n}\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n}\n\n//\n// Connection handlers\nvar errorHandler = function(self) {\n  return function(err) {\n    if(connectionAccounting) deleteConnection(self.id);\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));\n    // Emit the error\n    if(self.listeners('error').length > 0) self.emit(\"error\", MongoError.create(err), self);\n  }\n}\n\nvar timeoutHandler = function(self) {\n  return function() {\n    if(connectionAccounting) deleteConnection(self.id);\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));\n    // Emit timeout error\n    self.emit(\"timeout\"\n      , MongoError.create(f(\"connection %s to %s:%s timed out\", self.id, self.host, self.port))\n      , self);\n  }\n}\n\nvar closeHandler = function(self) {\n  return function(hadError) {\n    if(connectionAccounting) deleteConnection(self.id);\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));\n\n    // Emit close event\n    if(!hadError) {\n      self.emit(\"close\"\n        , MongoError.create(f(\"connection %s to %s:%s closed\", self.id, self.host, self.port))\n        , self);\n    }\n  }\n}\n\nvar dataHandler = function(self) {\n  return function(data) {\n    // Parse until we are done with the data\n    while(data.length > 0) {\n      // If we still have bytes to read on the current message\n      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if(remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          self.bytesRead = self.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          try {\n            var emitBuffer = self.buffer;\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n            // Emit the buffer\n            self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n          } catch(err) {\n            var errorObject = {err:\"socketHandler\", trace:err, bin:self.buffer, parseState:{\n              sizeOfMessage:self.sizeOfMessage,\n              bytesRead:self.bytesRead,\n              stubBuffer:self.stubBuffer}};\n            // We got a parse Error fire it off then keep going\n            self.emit(\"parseError\", errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if(self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if(self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n\n          } else {\n\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            self.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, self.stubBuffer.length);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        } else {\n          if(data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            // If we have a negative sizeOfMessage emit error and return\n            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {err:\"socketHandler\", trace:'', bin:self.buffer, parseState:{\n                sizeOfMessage: sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(self.buffer, 0);\n              // Update bytes read\n              self.bytesRead = data.length;\n              // Update sizeOfMessage\n              self.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n\n            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {\n              try {\n                emitBuffer = data;\n                // Reset state of buffer\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null;\n                // Exit parsing loop\n                data = new Buffer(0);\n                // Emit the message\n                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n              } catch (err) {\n                self.emit(\"parseError\", err, self);\n              }\n            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {err:\"socketHandler\", trace:null, bin:data, parseState:{\n                sizeOfMessage:sizeOfMessage,\n                bytesRead:0,\n                buffer:null,\n                stubBuffer:null}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n\n              // Clear out the state of the parser\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n            } else {\n              emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length)\n            // Copy the data to the stub buffer\n            data.copy(self.stubBuffer, 0);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  }\n}\n\n// List of socket level valid ssl options\nvar legalSslSocketOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers'\n  , 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve'\n  , 'secureProtocol', 'secureContext', 'session'\n  , 'minDHSize'];\n\nfunction merge(options1, options2) {\n  // Merge in any allowed ssl options\n  for(var name in options2) {\n    if(options2[name] != null && legalSslSocketOptions.indexOf(name) != -1) {\n      options1[name] = options2[name];\n    }\n  }\n}\n\n/**\n * Connect\n * @method\n */\nConnection.prototype.connect = function(_options) {\n  var self = this;\n  _options = _options || {};\n  // Set the connections\n  if(connectionAccounting) addConnection(this.id, this);\n  // Check if we are overriding the promoteLongs\n  if(typeof _options.promoteLongs == 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n    self.responseOptions.promoteValues = _options.promoteValues;\n    self.responseOptions.promoteBuffers = _options.promoteBuffers;\n  }\n\n  // Create new connection instance\n  var connection_options;\n  if (self.domainSocket) {\n    connection_options = {path: self.host};\n  } else {\n    connection_options = {port: self.port, host: self.host};\n    if (self.family !== void 0) {\n      connection_options.family = self.family; \n    }\n  }\n  self.connection = net.createConnection(connection_options);\n\n  // Set the options for the connection\n  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  self.connection.setTimeout(self.connectionTimeout);\n  self.connection.setNoDelay(self.noDelay);\n\n  // If we have ssl enabled\n  if(self.ssl) {\n    var sslOptions = {\n        socket: self.connection\n      , rejectUnauthorized: self.rejectUnauthorized\n    }\n\n    // Merge in options\n    merge(sslOptions, this.options);\n    merge(sslOptions, _options);\n\n    // Set options for ssl\n    if(self.ca) sslOptions.ca = self.ca;\n    if(self.crl) sslOptions.crl = self.crl;\n    if(self.cert) sslOptions.cert = self.cert;\n    if(self.key) sslOptions.key = self.key;\n    if(self.passphrase) sslOptions.passphrase = self.passphrase;\n\n    // Override checkServerIdentity behavior\n    if(self.checkServerIdentity == false) {\n      // Skip the identiy check by retuning undefined as per node documents\n      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n      sslOptions.checkServerIdentity = function() {\n        return undefined;\n      }\n    } else if(typeof self.checkServerIdentity == 'function') {\n      sslOptions.checkServerIdentity = self.checkServerIdentity;\n    }\n\n    // Set default sni servername to be the same as host\n    if(sslOptions.servername == null) {\n      sslOptions.servername = self.host;\n    }\n\n    // Attempt SSL connection\n    self.connection = tls.connect(self.port, self.host, sslOptions, function() {\n      // Error on auth or skip\n      if(self.connection.authorizationError && self.rejectUnauthorized) {\n        return self.emit(\"error\", self.connection.authorizationError, self, {ssl:true});\n      }\n\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout);\n      // We are done emit connect\n      self.emit('connect', self);\n    });\n    self.connection.setTimeout(self.connectionTimeout);\n  } else {\n    self.connection.once('connect', function() {\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout);\n      // Emit connect event\n      self.emit('connect', self);\n    });\n  }\n\n  // Add handlers for events\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n}\n\n/**\n * Unref this connection\n * @method\n * @return {boolean}\n */\nConnection.prototype.unref = function() {\n  if (this.connection) this.connection.unref();\n  else {\n    var self = this;\n    this.once('connect', function() {\n      self.connection.unref();\n    });\n  }\n}\n\n/**\n * Destroy connection\n * @method\n */\nConnection.prototype.destroy = function() {\n  // Set the connections\n  if(connectionAccounting) deleteConnection(this.id);\n  if(this.connection) {\n    // Catch posssible exception thrown by node 0.10.x\n    try { this.connection.end(); } catch (err) {}\n    // Destroy connection\n    this.connection.destroy();\n  }\n\n  this.destroyed = true;\n}\n\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\nConnection.prototype.write = function(buffer) {\n  var i;\n  // Debug Log\n  if(this.logger.isDebug()) {\n    if(!Array.isArray(buffer)) {\n      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n    } else {\n      for(i = 0; i < buffer.length; i++)\n        this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));\n    }\n  }\n\n  // Double check that the connection is not destroyed\n  if(this.connection.destroyed === false) {\n    // Write out the command\n    if(!Array.isArray(buffer)) {\n      this.connection.write(buffer, 'binary');\n      return true;\n    }\n\n    // Iterate over all buffers and write them in order to the socket\n    for(i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');\n    return true;\n  } \n\n  // Connection is destroyed return write failed\n  return false;\n}\n\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\nConnection.prototype.toString = function() {\n  return \"\" + this.id;\n}\n\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\nConnection.prototype.toJSON = function() {\n  return {id: this.id, host: this.host, port: this.port};\n}\n\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\nConnection.prototype.isConnected = function() {\n  if(this.destroyed) return false;\n  return !this.connection.destroyed && this.connection.writable;\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"},"hash":"2304fdf430271e42c648105ee843c6be"}